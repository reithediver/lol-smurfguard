"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportGenerator = exports.ReportGenerator = void 0;
class ReportGenerator {
    /**
     * Generate CSV report for bulk analysis
     */
    generateCSV(analyses) {
        const headers = [
            'Summoner Name',
            'Smurf Probability (%)',
            'Risk Level',
            'Champion Performance Score',
            'Spell Pattern Score',
            'Playtime Gap Score',
            'First-Time Champions Count',
            'Spell Changes Count',
            'Analysis Date'
        ];
        const rows = analyses.map(analysis => [
            analysis.summonerName,
            (analysis.probability * 100).toFixed(2),
            analysis.riskLevel,
            (analysis.championPerformance.overallPerformanceScore * 100).toFixed(2),
            (analysis.summonerSpellUsage.patternChangeScore * 100).toFixed(2),
            (analysis.playtimeGaps.totalGapScore * 100).toFixed(2),
            analysis.championPerformance.firstTimeChampions.length,
            analysis.summonerSpellUsage.spellPlacementChanges.length,
            analysis.metadata.analysisDate.toISOString().split('T')[0]
        ]);
        return [headers, ...rows]
            .map(row => row.map(cell => `"${cell}"`).join(','))
            .join('\n');
    }
    /**
     * Generate detailed JSON report
     */
    generateJSON(analyses) {
        return JSON.stringify({
            reportMetadata: {
                generatedAt: new Date().toISOString(),
                totalPlayers: analyses.length,
                highRiskPlayers: analyses.filter(a => a.probability > 0.8).length,
                moderateRiskPlayers: analyses.filter(a => a.probability >= 0.4 && a.probability <= 0.8).length,
                lowRiskPlayers: analyses.filter(a => a.probability < 0.4).length,
                algorithmVersion: '1.0.0'
            },
            analyses: analyses
        }, null, 2);
    }
    /**
     * Generate tournament summary report
     */
    generateTournamentSummary(analyses) {
        const highRisk = analyses.filter(a => a.probability > 0.8);
        const moderateRisk = analyses.filter(a => a.probability >= 0.4 && a.probability <= 0.8);
        const lowRisk = analyses.filter(a => a.probability < 0.4);
        const report = `
LEAGUE OF LEGENDS SMURF DETECTION REPORT
Generated: ${new Date().toISOString()}

=== SUMMARY ===
Total Players Analyzed: ${analyses.length}
High Risk (80%+): ${highRisk.length} players
Moderate Risk (40-80%): ${moderateRisk.length} players  
Low Risk (<40%): ${lowRisk.length} players

=== HIGH RISK PLAYERS ===
${highRisk.map(player => `${player.summonerName}: ${(player.probability * 100).toFixed(1)}% (${player.riskLevel})`).join('\n')}

=== MODERATE RISK PLAYERS ===
${moderateRisk.map(player => `${player.summonerName}: ${(player.probability * 100).toFixed(1)}% (${player.riskLevel})`).join('\n')}

=== ALGORITHM DETAILS ===
Champion Performance Weight: 65%
Summoner Spell Pattern Weight: 25%
Playtime Gap Weight: 10%
Player Association Weight: 5%

Detection factors include:
- First-time champion performance analysis
- Summoner spell placement pattern changes
- Suspicious gameplay gaps (>1 week)
- High-ELO player associations

=== RECOMMENDATIONS ===
${highRisk.length > 0 ?
            `⚠️  ${highRisk.length} player(s) require manual review for potential smurfing` :
            '✅ No high-risk players detected'}
${moderateRisk.length > 0 ?
            `📋 ${moderateRisk.length} player(s) may warrant additional scrutiny` :
            ''}

Report generated by League of Legends Smurf Detection System v1.0.0
    `.trim();
        return report;
    }
    /**
     * Send CSV file as download
     */
    sendCSVDownload(res, analyses, filename = 'smurf-analysis-report') {
        const csv = this.generateCSV(analyses);
        const timestamp = new Date().toISOString().split('T')[0];
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.csv"`);
        res.send(csv);
    }
    /**
     * Send JSON file as download
     */
    sendJSONDownload(res, analyses, filename = 'smurf-analysis-report') {
        const json = this.generateJSON(analyses);
        const timestamp = new Date().toISOString().split('T')[0];
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.json"`);
        res.send(json);
    }
    /**
     * Send tournament summary as text file
     */
    sendTournamentSummaryDownload(res, analyses, filename = 'tournament-summary') {
        const summary = this.generateTournamentSummary(analyses);
        const timestamp = new Date().toISOString().split('T')[0];
        res.setHeader('Content-Type', 'text/plain');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.txt"`);
        res.send(summary);
    }
    /**
     * Generate analysis statistics
     */
    generateStatistics(analyses) {
        if (analyses.length === 0) {
            return {
                totalPlayers: 0,
                averageProbability: 0,
                riskDistribution: { high: 0, moderate: 0, low: 0 },
                topFactors: []
            };
        }
        const totalProbability = analyses.reduce((sum, a) => sum + a.probability, 0);
        const averageProbability = totalProbability / analyses.length;
        const riskDistribution = {
            high: analyses.filter(a => a.probability > 0.8).length,
            moderate: analyses.filter(a => a.probability >= 0.4 && a.probability <= 0.8).length,
            low: analyses.filter(a => a.probability < 0.4).length
        };
        // Analyze which factors are most commonly triggered
        let championFactorTriggered = 0;
        let spellFactorTriggered = 0;
        let gapFactorTriggered = 0;
        analyses.forEach(analysis => {
            if (analysis.championPerformance.overallPerformanceScore > 0.5)
                championFactorTriggered++;
            if (analysis.summonerSpellUsage.patternChangeScore > 0.3)
                spellFactorTriggered++;
            if (analysis.playtimeGaps.totalGapScore > 0.3)
                gapFactorTriggered++;
        });
        const topFactors = [
            { factor: 'Champion Performance', triggered: championFactorTriggered, percentage: (championFactorTriggered / analyses.length) * 100 },
            { factor: 'Spell Patterns', triggered: spellFactorTriggered, percentage: (spellFactorTriggered / analyses.length) * 100 },
            { factor: 'Playtime Gaps', triggered: gapFactorTriggered, percentage: (gapFactorTriggered / analyses.length) * 100 }
        ].sort((a, b) => b.triggered - a.triggered);
        return {
            totalPlayers: analyses.length,
            averageProbability: averageProbability * 100,
            riskDistribution,
            topFactors
        };
    }
}
exports.ReportGenerator = ReportGenerator;
exports.reportGenerator = new ReportGenerator();
